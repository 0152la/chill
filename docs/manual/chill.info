This is chill.info, produced by makeinfo version 6.3 from CHiLL.texi.

This manual describes CHiLL (version 0.2.4 November 2016), a
source-to-source translator for optimizing loop based calculations.

   Copyright (C) 2008 University of Southern California
Copyright (C) 2009-2016 University of Utah

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
published by the Free Software Foundation.  To receive a copy of the GNU
Free Documentation License, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.


   Published by the University of Utah School of Computing
Compiler Technology to Optimize Performance Research Group
<ctop.cs.utah.edu/ctop/>
50 S., Central Campus Dr., Salt Lake City, UT 84112


File: chill.info,  Node: Top,  Next: First Chapter,  Up: (dir)

The Composable High Level Loop Source-to-Source Translator
**********************************************************

This manual is for The Composable High Level Loop Source-to-Source
Translator, aka CHiLL (version 0.2.4).

* Menu:

* First Chapter::       Introduction
* Second Chapter::      Background
* Third Chapter::       The CHiLL Scripting Language
* Index::               Complete index.


File: chill.info,  Node: First Chapter,  Next: Second Chapter,  Prev: Top,  Up: Top

1 Introduction
**************

CHiLL is a source-to-source translator for composing high level loop
transformations to improve the performance of nested loop calculations
written in C, C++ or Fortran.  CHiLL's operations are driven by a script
which is generated or supplied by the user that specifies the location
of the original source file, the function and loops to modify and the
transformations to apply.  CHiLL can be configured to include support
for the NVIDIA CUDA compiler.  In this mode, CHiLL can generate source
code for both host functions and device functions to be compiled and
executed on NVIDIA GPUs.

1.1 Intended Audience
=====================

This manual is intended for C/C++ or Fortran programmers wishing to
optimize loop based calculations.  The user should have sufficient
knowledge of the underlying hardware on which the code should execute to
generate an optimization strategy.

1.2 Getting CHiLL
=================

CHiLL is available in source form from
<https://github.com/CtopCsUtahEdu> and requires the ROSE compiler from
Lawrence Livermore National Laboratory (see
<http://rosecompiler.org>)(1).  When ROSE is available CHiLL can be
installed and tested by executing the following commands in the source
direcory.

     ./configure --with-interface=python --prefix=<INSTALLDIR> \
                 --with-rose=<ROSEINSTALLDIR> --with-boost=<BOOSTINSTALLDIR>
     make -j`nproc`
     make -j`nproc` install
     cd test-chill; ./runtests

   If you have problems with installation, find bugs or have comments,
questions or suggestions for this document, please send mail to
<chill-support@cs.utah.edu>.

1.3 Invoking CHiLL
==================

The C program below is an implementation of matrix multiplication as a
direct translation of an optimized Fortran program where all of the
loops are ordered such that memory accesses to the arrays a, b and c are
all in column order.  Since C stores arrays in row major order there is
an opportunity for better cache utilization if the arrays are accessed
as rows and not columns.  We will refer to this code often and assume it
is in a file named 'mm.c'.

     void mm(float **A, float **B, float **C,
             int ambn, int an, int bm) {
       int i, j, n;
       for(i = 0; i < an; i++)
         for(j = 0; j < bm; j++) {
           C[i][j] = 0.0f;
           for(n = 0; n < ambn; n++)
             C[i][j] += A[i][n] * B[n][j];
         }
     }

   Permuting the order of the loops from i, j, n to n, j, i results in
the more cache centric C algorithm as shown below where all array
accesses are in row major order.

     void mm(float **A, float **B, float **C,
     	int ambn, int an, int bm) {
       int i, j, k;
       for (n = 0; n <= ambn - 1; n += 1)
         for (j = 0; j <= bm - 1; j += 1)
           if (n <= 0)
             for (i = 0; i <= an - 1; i += 1) {
               C[i][j] = 0.0f;
               C[i][j] += (A[i][n] * B[n][j]);
             }
           else
             for (i = 0; i <= an - 1; i += 1)
               C[i][j] += (A[i][n] * B[n][j]);
     }

   The interchanges of the outer and innermost loops can be done in
CHiLL with this simple Python script.

     from chill import *
     source('mm.c')
     procedure('mm')
     loop(0)
     known(['ambn > 0', 'an > 0', 'bm > 0'])
     permute([3,2,1])
     print_code()

   The first line of the script 'from chill import *' loads the CHiLL
interface into the python interpreter.  The commands 'source' and
'procedure' identify the source file and the procedure to modify.  The
'loop' command specifies the loop nest to be transformed.  The 'known'
command specifies constraints on parameters that are known and the
transformation 'permute([3,2,1])' exchanges the inner and outermost
loops.  Finally the command 'print_code' prints the transformed loop
nest in a C-like pseudo code showing the loops, indices and statements.

   Assuming for this example that that the script above is in the file
'mm.py', the command 'chill mm.py' would print to STDOUT pseudo code
similar to that shown below and produce the transformed code in the file
'rose_mm.c' (2)


     for(n = 0; n <= ambn-1; n++)
       for(j = 0; j <= bm-1; j++)
         if (n <= 0)
           for(i = 0; i <= an-1; i++) {
             s0(i,j,n);
             s1(i,j,n);
           }
         else
           for(i = 0; i <= an-1; i++)
             s1(i,j,n);

   ---------- Footnotes ----------

   (1) Building ROSE requires very specific versions of GNU autoconf,
gcc and the boost libraries.  If you do not have ROSE installed then
please see and modify the script 'buildall' which was used to install
CHiLL on Blue Waters at NCSA.

   (2) The code produced by the current version of CHiLL does not
preserve loop variables names in the transformed code which makes it
difficult to see the effects of a transformation.  In this manual we
have used the original loop variable names in the generated code to make
it easier to understand.


File: chill.info,  Node: Second Chapter,  Next: Third Chapter,  Prev: First Chapter,  Up: Top

2 Background
************

Before CHiLL applies a user specified transformation to the loop
structure it first insures that the transformed code will produce the
same results as the original code.  It does this by determining all
dependences between statements in the original program and then
requiring that any and all transformations that are applied preserve the
dependences between the statements in the original code.

   Conceptually CHiLL treats each statement in a source program as one
of three basic types; a loop, a conditional or a statement.  When we
refer to "a statement" in CHiLL, we are referring to a block of one or
more actual program statements which have a single uninterrupted
execution path through them and we notationally represent it as a
function which is passed the values of the indices of all loops
enclosing it.

   For each statement we compute an "iteration vector" that encodes the
the absolute execution order of the statement as a function of its
lexical position in the source code and the index values of the
enclosing loops.  We then define the "iteration space" for the statement
by joining the iteration vector with the constraints on each index that
is in an enclosing loop.

   Next we analyze the memory access patterns of the statements and
loops.  We compute the set of "dependences" by taking all statements
pair-wise and finding those pairs of statements (S_1, S_2) where there
exists an iteration vector i_1 and i_2 in the respective iteration
spaces of S_1 and S_2 such that S_1(i_1) and S_2(i_2) both refer to the
same memory location and one or both of them write to that location.
The "distance vector" defined by i_2 - i_1 gives the execution distance
from the source statement S_1 to the sink statement S_2.

   If a dependence exists between statements S_1 and S_2 with the
constraint that S_1 must execute before S_2 in the original code then
that constraint must be preserved across any and all transformations.
If a dependence exists that can not be preserved across a transformation
then CHiLL alerts the user to this problem.  Dependence information
between S_1 and S_2 is maintained by a "dependence vector" which
encapsulates the notion of all the distance vectors where statement S_1
must execute before S_2.

   The diagnostic commands 'print_space' and 'print_dep' will print the
iteration space of each statement and the dependences between all pairs
of statements.  The command 'remove_dep' will force the removal of a
dependence leaving responsibility for the correctness of the
transformation to the user.

2.1 Iteration Vectors
=====================

Given a loop nest with a maximum loop depth of n, we define for each
executed statement an iteration vector that encodes the time of
execution of a statement executed with specific values for the loop
indices which enclose the statement.  This allows us to determine the
relative order of execution of any two statements so that dependences
between statements can be preserved.

   We define an iteration vector for a nest of n loops as i = {c_0, l_1,
c_1, l_2, ..., c_n, l_n, c_{n+1} } where l_k is the value of the
index(1) of the loop at nesting level k and c_k is an auxiliary loop
used to track the lexigraphical ordering of statement executed within
the loop nested at level k.  The outermost loop level in the nest is 1
and c_0 lexigraphically orders any statements that precede the first
loop.

   At this level of abstraction we only care about loops and blocks of
code between loops.  The even numbered elements {c_0, c_1, ..., c_{n+1}
} are always constant integers that describe the static lexigraphical
ordering of the statements in the original code.  The odd numbered
elements {l_1, ..., l_n } represent the current values of the loop
levels.  This scheme allows a uniform method to both track both the
progression of the loop indices as well as the execution order of
statements within each loop.

   Iteration vectors are ordered and thus can be used to enforce
dependences between statements.  Iteration vector i precedes iteration
j, denoted i < j, if and only if i[1:n-1] < j[1:n-1] or i[1:n-1] =
j[1:n-1] and i[n] < j[n].

   Given two statements S_0 which executes at a time specified by
iteration vector i_0 and a statement S_1 which executes at a time
specified by iteration vector i_1, then the execution of S_0 precedes
that of S_1 if and only if i_0 < i_1.

2.2 Iteration Spaces
====================

Consider the following loop nest below.  There are three loop levels to
track the three indices i, j and k and four auxiliary loop levels to
track the relative execution of the statements within the loops.

     S_0
     for (i ...) {
       S_1
       S_2
       for (j ...) {
         S_3
         for (k ...) {
           S_4
         }
         S_5
       }
       S_6
     }

   An iteration space is is a set of iteration vectors.  It is usually
specified in set notation with one or more values of l specified as an
integer variable along with constraints on the variables.  The iteration
space for each statement is shown below as a set of integer tuples.  In
practice, the upper and lower bounds of each loop index would be
specified in each set condition as well.

     S_0: {[0, 0, 0, 0, 0, 0, 0]}
     S_1: {[1, i, 0, 0, 0, 0, 0]}
     S_2: {[1, i, 1, 0, 0, 0, 0]}
     S_3: {[1, i, 2, j, 0, 0, 0]}
     S_4: {[1, i, 2, j, 1, k, 0]}
     S_5: {[1, i, 2, j, 2, 0, 0]}
     S_6: {[1, i, 3, 0, 0, 0, 0]}

   If we were were told that the current point of execution of the above
loop nest was described by the iteration vector [1, 3, 2, 6, 2, 0, 0] we
would know that statement S_5 was executing with the indices of the
loops being i = 3 and j = 6.

   The 'print_space' command will print the iteration space for every
statement (or block of statements).  For example 'print_space' applied
to the following code.


     for(i = 0; i < an; i++)
       for(j = 0; j < bm; j++) {
         C[i][j] = 0.0f;
         for(n = 0; n < ambn; n++)
           C[i][j] += A[i][n] * B[n][j];
       }
   gives the following results.

     s0: {Sym=[bm,an,ambn] [t1,t2,t3,t4,t5,t6,t7] : t1=0 && t3=0 && t5=0 && 
          t7=0 && t6=0 && 0<=t2<an && 0<=t4<bm && 1<=ambnyes }
     s1: {Sym=[ambn,bm,an] [t1,t2,t3,t4,t5,t6,t7] : t1=0 && t3=0 && t5=0 && 
          t7=0 && 0<=t2<an && 0<=t6<ambn && 0<=t4<bm }

2.3 Dependences
===============

There are two general categories of dependences, control dependences and
data dependences.

   A "control dependence" exist when one statement is executed
conditionally on the result of another.  For example, in the statements
below S_1 cannot be executed before S_0 and thus S_1 has a control
dependence on S_0.
       S_0     if (x != 0)
       S_1       a /= x;

   A "data dependence" exists between statements S_0 and S_1 (meaning
S_1 depends on statement S_0) if and only if there is a plausible
run-time execution path from S_0 to S_1, both statements access the same
memory location and at least one of them stores to it.  There are three
types of data dependences:

   A "true dependence" exists when S_0 writes to a location that is
later read by S_1.

       S_0     x = ...
       S_1     ... = x

   An "antidependence" exists when S_0 reads from a location that is
later written to by S_1.
       S_0     ... = x
       S_1     x = ...

   An "output dependence" exists when S_0 writes to a location that is
later written to by S_1.
       S_0     x = ...
       S_1     x = ...

   In the parlance of hardware design, a true dependence is known as a
RAW (read after write) hazard, an antidependence is a WAR (write after
read) hazard and an output dependence is a WAW (write after write)
hazard.  These dependences are fairly intuitively and are used
instinctively by every programmer to determine the correct order of
statements in sequential code.  However, when loops and arrays are
involved these same data dependences arise in more subtle ways.

2.4 Dependences with loops and arrays
=====================================

It is useful to categorize data dependences in loops into two types.
Consider a loop that contains two statements call them S_0 and S_1.  If
both S_0 and S_1 reference the same memory location within the same
iteration as they do in this case, then the dependence is
"loop-independent".  If statement S_0 and S_1 reference the same memory
location in different iterations, then the dependence is created by the
loop and it is said to be "loop-carried".

   As an example the loop below which has two loop-carried dependences
and two loop-independent dependences.

            for (i = 0; i < n; i++) {
       S_0     a[i + 1] = b[i];
       S_1     b[i + 1] = a[i];
       S_2     c[i] = a[i] + b[i];
            }

   In every iteration other than the first, S_1 reads an element of
'a[]' that was written to by S_0 in the previous iteration and thus
there is dependence from S_0 to S_1.  Because S_0 appears before S_1 in
the loop, it is a "loop-carried forward" true dependence.

   Likewise, for every iteration other than the first, S_0 uses a value
of 'b[]' that was written by S_1 in the previous iteration and thus
there is also a dependence from S_1 to S_0 but because S_1 appears after
S_0 in the loop, it is a "loop-carried backward" true dependence.

   Finally S_2 reads a value of 'a[]' that was written by S_0 and a
value of 'b[]' that was written by S_1 in the same iteration and thus
there are two "loop-independent" true dependence, one is S_2 on S_0 and
the other is of S_2 on S_1.

2.5 Distance Vectors
====================

Given two statements S_1 and S_2 with iteration vector i_1 and i_2
respectively where S2 depends on S1 we define the distance vector d of
the dependence as follows.  Let
     i_1 = {c_0', l_1', c_1', l_2', ..., c_n', l_n', c_{n+1}'} and
     i_2 = {c_0, l_1, c_1, l_2, ..., c_n, l_n, c_{n+1}}
   then we define the distance vector as
     d = {l_1-l_1', l_2-l_2', ..., l_n-l_n'}.
   The only statement in the nested loop below has a loop-dependent
dependence with itself.
       for(i = 0; i < 2 * n; i++)
         for (j = 1; j < m; j++)
           a[i+1][j-1] = a[i][j] + b[i][j];

   The right hand side of the assignment reads array A at iteration
vector i_R below and the left hand side of the assignment writes to the
same location of the array at the iteration vector i_W.

     i_R = {0, i, 0, j, 0}
     i_W = {0, i+1, 0, j-1, 0}.

   Because i_R<i_W this is a read/write dependence and the distance
vector is
     d=i_W-i_R={1, -1}.

   The command 'print_dep' applied to this loop yields 's0->s0:
a:true(1, -1)'

2.6 Direction Vectors
=====================

In the same way that an iteration space is a set of iteration vectors, a
direction vector is a summarization of a set of distance vectors between
two statements.

   In the matrix multiplication loop nest below, statement S_0
initializes the value of 'C[i][j]' and statement S_1 accumulates the
inner product into it.  S_1 has multiple dependences on S_0 as the
initialization must occur before _every_ accumulation statement S_1
executed in the loop.

            for(i = 0; i < an; i++)
              for(j = 0; j < bm; j++) {
       S_0        C[i][j] = 0.0f;
                for(n = 0; n < ambn; n++)
       S_1          C[i][j] += A[i][n] * B[n][j];
              }

   In general, given a nest with n loops each direction vector has the
form (d_1, d_2, ..., d_n) where The value of d_i indicates the range of
distances between the source and sink carried by loop i and is one of
the following symbols below where n, n_l and n_u represent integer
values in the iteration space of the loop.
        Symbol         Lower Bound    Upper Bound
-----------------------------------------------------
        n              n              n
        n_l{\sim}n_u   n_l            n_u
        *              -\infty        +\infty
        -              -\infty        -1
        n-             -\infty        n
        +              1              +\infty
        n+             n              +\infty

   Notice that neither the symbols + nor - includes the value of 0.  The
reason is that a distance of 0 means that the dependence is not
loop-carried which CHiLL likes to separate from dependences that are
loop-carried.  This is shown below with output of the command
'print_dep' on the above code.

     s0->s1: C:true(0,0,+) C:true(0,0,0) C:output(0,0,+) C:output(0,0,0)
     s1->s1: C:anti(0,0,+) C:output(0,0,+)

2.7 Legality of Transformations
===============================

From the definition of an iteration vector it is clear that
transformations that permute the loop structure also permute the
iteration vector and distance vectors of all dependences in exactly the
same way.  Because the distance vector is the distance from the source
to the sink, any permutation of the loop structure that causes the
permuted distance vector to be negative is illegal as the transformation
has caused the sink to execute before the source.

   Looking at the transformed elements of an iteration vector or
distance vector from left to right (or outer loop to inner loop), if the
first non-zero loop element is negative, then the distance vector is
negative and the transformation is illegal.

   ---------- Footnotes ----------

   (1) with a suitable transformation such that the index is
monotonically increasing as the loop progresses


File: chill.info,  Node: Third Chapter,  Next: Index,  Prev: Second Chapter,  Up: Top

3 The CHiLL Scripting Language
******************************

3.1 Loop and Statement Identification
=====================================

The first two commands in every CHiLL script identify the source file
and the procedure to modify.  Only one source file and one procedure can
be modified in any single script.

   Individual loops within a loop nest are identified by the level that
they are nested and the statement that they surround.  The outermost
loop of a nest is always loop level 1.  Thus in the introductory
example, the transformation 'permute([3,2,1])' exchanged the inner and
outermost loops.

   It is very important to realize that every transformation has the
capability to insert or reorder the loops and thus the identification of
a specific loop will change after a transformation.  In the example
referenced above the j, k and i loops that were respectively at levels
1, 2 and 3 before the permutation are now at levels 3, 2 and 1 after the
transformation.  Any subsequent transformation must use these new loop
levels to identify the individual loops.

   Consider the pseudo code below.

     for (i ...) {
       S_0
       for (j ...) {
         S_1
         for (k ...)
           S_2
       }
       for (j ...)
         S_3
     }

   The loop level alone insufficient to uniquely determine a specific
loop within a nest unless a statement enclosed by the loop is also
provided.  Statements are initially numbered in the order they appear
from top to bottom in the nest starting with zero.  Transformations may
also insert or reorder the statements in the nest but the identification
of a specific statement will not change after a transformation.

3.2 Commands
============

 -- Command: source (string FILENAME)
     The 'source' command specifies the filename of the original code to
     be transformed.  There can only be one 'source' command in a script
     and it must precede the 'loop' command.

 -- Command: procedure (string NAME)
     The 'procedure' command specifies the procedure name in the file to
     transform.  There can only be one procedure modified in a given
     script.

 -- Command: loop (int LEVEL)
 -- Command: loop (int START, int END)
     The 'loop' command specifies the loop nest to be transformed by
     specifying the top level loop of the nest.  The first form of the
     command selects a nest contained in a single top level loop.  The
     second form takes a range of top level loops and treats them as a
     single unified nest.

     Top level loops are those loops at procedure scope and are numbered
     starting from zero.  Once a loop nest is selected by the 'loop'
     command the outermost loop of the nest is numbered from one.

     The 'loop' command can be issued multiple times in a script to
     select and modify different top level loops within the same file.

 -- Command: print_code ()
     The 'print code' commands display C-like pseudo code of the nest
     showing the loops, indices and statements.  Statements in the
     pseudo-code appears as a function indexed by the loop indices as if
     it were a call to the block of code.

 -- Command: print_dep ()
     The 'print_dep' command displays the dependences between all
     statements in the current nest.  Given a nest with n loops each
     individual dependence has the form:
          VAR:TYPE(d_1, d_2, ..., d_n)
     where VAR is the variable name that is creating the dependence,
     TYPE is the type of dependence which is one of _quasi, true, anti,
     output, input, control or unknown.

     The value of d_i indicates the distance or range of distances where
     a dependence exists between the source and sink carried by loop i.

 -- Command: print_space ()
     The 'print_space' command displays the iteration space for each
     statement in the current nest.

 -- Command: exit ()
     The 'exit' command exists the script.

 -- Command: known (string COND)
     The 'known' command adds a condition as an expression.  The value
     of COND can be a string or a list of strings.

 -- Command: remove_dep (int STMT1, int STMT2)
     The 'remove_dep' removes a dependence between two statements in the
     loop nest.

3.3 Transformations
===================

Distribute
----------

 -- Transform: distribute (set<int> STMTS, int LOOP)
     Distribute the set of statements in STMTS such that each statement
     executes under its own clone of the common loop structure down to
     and including level LOOP.

     The transformation is legal if and only if, all loop-carried
     dependences between the statements in STMTS are contained entirely
     to loop levels less than LOOP.
Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                               int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known(['ambn > 0', 'an > 0', 'bm > 0'])    for(j = 0; j < bm; j++) {
distribute([0,1], 1)                       C[i][j] = 0.0f;
print_code()                               for(n = 0; n < ambn; n++)
                                             C[i][j] += A[i][n] * B[n][j];
                                         }
                                     }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= an-1; t2++) {      void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= bm-1; t4++) {            int ambn, int an, int bm) {
    s0(t2,t4,0);                       int i, j, n;
  }                                    for (i = 0; i <= an - 1; i += 1)
}                                        for (j = 0; j <= bm - 1; j += 1)
for(t2 = 0; t2 <= an-1; t2++) {            C[i][j] = 0.0f;
  for(t4 = 0; t4 <= bm-1; t4++) {      for (i = 0; i <= an - 1; i += 1)
    for(t6 = 0; t6 <= ambn-1; t6++) {    for (j = 0; j <= bm - 1; j += 1)
      s1(t2,t4,t6);                        for (n = 0; n <= ambn - 1; n += 1)
    }                                        C[i][j] += (A[i][n] * B[n][j]);
  }                                  }
}

Fuse
----

 -- Transform: fuse (set<int> STMTS, int LOOP)
     Fuse the set of statements in STMTS such that all statement
     executes under the common loop structure down to and including
     level LOOP.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('dist.c')                             int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0, 1)                             for (i = 0; i <= an - 1; i += 1)
known(['ambn > 0', 'an > 0', 'bm > 0'])    for (j = 0; j <= bm - 1; j += 1)
fuse([0,1], 1)                             C[i][j] = 0.0f;
print_code()                         
                                       for (i = 0; i <= an - 1; i += 1)
                                         for (j = 0; j <= bm - 1; j += 1)
                                           for (n = 0; n <= ambn - 1; n += 1)
                                             C[i][j] += (A[i][n] * B[n][j]);
                                     }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= an-1; t2++) {      void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= bm-1; t4++) {            int ambn, int an, int bm) {
    s0(t2,t4,0);                       int i, j, n;
    s1(t2,t4,0);                       for (i = 0; i <= an - 1; i += 1)
    for(t6 = 1; t6 <= ambn-1; t6++) {    for (j = 0; j <= bm - 1; j += 1) {
      s1(t2,t4,t6);                        C[i][j] = 0.0f;
    }                                      C[i][j] += (A[i][0] * B[0][j]);
  }                                        for (n = 1; n <= ambn - 1; n += 1)
}                                            C[i][j] += (A[i][n] * B[n][j]);
                                         }
                                     }

Peel
----

 -- Transform: peel (int STMT, int LOOP, int AMOUNT = 1)
     The 'peel' transformation unrolls a specified number of iterations
     of a statement from the beginning or the end of a loop at level
     LOOP.

     If AMOUNT is positive then statements are peeled from the start of
     the loop, if negative then the statements are peeled from the end.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                               int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known(['ambn > 4', 'an > 0', 'bm > 0'])    for(j = 0; j < bm; j++) {
peel(1,3,4)                                C[i][j] = 0.0f;
print_code()                               for(n = 0; n < ambn; n++)
                                             C[i][j] += A[i][n] * B[n][j];
                                         }
                                     }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= an-1; t2++) {      void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= bm-1; t4++) {            int ambn, int an, int bm) {
    s2(t2,t4,0);                       int i, j, n;
    s3(t2,t4,0);                       for (i = 0; i <= an - 1; i += 1)  {
    s4(t2,t4,1);                         for (j = 0; j <= bm - 1; j += 1) {
    s5(t2,t4,2);                           C[i][j] = 0.0f;
    s6(t2,t4,3);                           C[i][j] += (A[i][0] * B[0][j]);
    for(t6 = 4; t6 <= ambn-1; t6++) {      if(2 <= ambn) {
      s1(t2,t4,t6);                          C[i][j] += (A[i][1] * B[1][j]);
    }                                        if(3 <= ambn) {
  }                                            C[i][j] += (A[i][2] * B[2][j]);
}                                              if(4 <= ambn)
                                                 C[i][j] += (A[i][3] * B[3][j]);
                                             }
                                           }
                                         }
                                       }
                                     }

Permute
-------

The 'permute' transformation interchanges the loops of a loop nest.
 -- Transform: permute (vector<int> P)
 -- Transform: permute (set<int> STMTS, vector<int> P)

     The loop nest to permute is specified by the statements in the set
     STMTS.  The loops in the nest are permuted according to the
     permutation vector P.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                               int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known(['ambn > 0', 'an > 0', 'bm > 0'])    for(j = 0; j < bm; j++) {
permute([3,1,2])                           C[i][j] = 0.0f;
print_code()                               for(n = 0; n < ambn; n++)
                                             C[i][j] += A[i][n] * B[n][j];
                                         }
                                     }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= ambn-1; t2++) {    void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= an-1; t4++) {            int ambn, int an, int bm) {
    if (t2 <= 0) {                     int i, j, n;
      for(t6 = 0; t6 <= bm-1; t6++) {  for (n = 0; n <= ambn - 1; n += 1)
        s0(t4,t6,t2);                    for (i = 0; i <= an - 1; i += 1)
        s1(t4,t6,t2);                      if (n <= 0)
      }                                      for (j = 0; j <= bm - 1; j += 1) {
    }                                          C[i][j] = 0.0f;
    else {                                     C[i][j] += (A[i][n] * B[n][j]);
      for(t6 = 0; t6 <= bm-1; t6++) {        }
        s1(t4,t6,t2);                      else
      }                                      for (j = 0; j <= bm - 1; j += 1)
    }                                          C[i][j] += (A[i][n] * B[n][j]);
  }                                  }
}

Reverse
-------

 -- Transform: reverse (set<int> STMTS, int LEVEL)
     The 'reverse' transformation changes the direction of the iteration
     through the loop and is a shortcut for the transformation
     'scale(STMTS, LEVEL, -1)'.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                               int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known(['ambn > 0', 'an > 0', 'bm > 0'])    for(j = 0; j < bm; j++) {
distribute([0,1],1)                        C[i][j] = 0.0f;
reverse([1],1)                             for(n = 0; n < ambn; n++)
reverse([1],2)                               C[i][j] += A[i][n] * B[n][j];
print_code()                             }
                                     }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= an-1; t2++) {      void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= bm-1; t4++) {            int ambn, int an, int bm) {
    s0(t2,t4,0);                       int i, j, n;
  }                                    for (i = 0; i <= an - 1; i += 1)
}                                        for (j = 0; j <= bm - 1; j += 1)
for(t2 = -an+1; t2 <= 0; t2++) {           C[i][j] = 0.0f;
  for(t4 = -bm+1; t4 <= 0; t4++) {     for (i = -an + 1; i <= 0; i += 1)
    for(t6 = 0; t6 <= ambn-1; t6++) {    for (j = -bm + 1; j <= 0; j += 1)
      s1(-t2,-t4,t6);                      for (n = 0; n <= ambn - 1; n += 1)
    }                                        C[-i][-j] += (A[-i][n] * B[n][-j]);
  }                                  }
}

Scale
-----

 -- Transform: scale (set<int> STMTS, int LOOP, int AMOUNT)
     The 'scale' transformation multiplies the index variable for the
     loop at level LOOP by AMOUNT and is a shortcut for the
     transformation 'skew'(STMTS, LOOP, [0, \dots{}, 0, AMOUNT]).

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                               int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known(['ambn > 0', 'an > 0', 'bm > 0'])    for(j = 0; j < bm; j++) {
distribute([0,1],1)                        C[i][j] = 0.0f;
scale([1],1,4)                             for(n = 0; n < ambn; n++)
scale([1],2,4)                               C[i][j] += A[i][n] * B[n][j];
print_code()                             }
                                     }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= an-1; t2++) {      void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= bm-1; t4++) {            int ambn, int an, int bm) {
    s0(t2,t4,0);                       int i, j, n;
  }                                    for (i = 0; i <= an - 1; i += 1)
}                                        for (j = 0; j <= bm - 1; j += 1)
for(t2 = 0; t2 <= 4*an-4; t2 += 4) {       C[i][j] = 0.0f;
  for(t4 = 0; t4 <= 4*bm-4; t4 += 4) {  for (i = 0; i <= 4 * an - 4; i += 4)
    for(t6 = 0; t6 <= ambn-1; t6++) {    for (j = 0; j <= 4 * bm - 4; j += 4)
      s1(t2/4,t4/4,t6);                    for (n = 0; n <= ambn - 1; n += 1)
    }                                        C[i/4][j/4] += A[i/4][n]*B[n][j/4];
  }                                  }
}

Shift
-----

 -- Transform: shift (set<int> STMTS, int LOOP, int AMOUNT)
     The 'shift' transformation adjusts the index of the loop at level
     LOOP by adding AMOUNT to what the the non transformed index would
     be and then subtracting AMOUNT from the index when it is used by
     statements in STMTS.  The aim of this transformation is to add a
     constant offset to the index used when executing selected
     statements and it is accomplishes by either adjusting the staring
     point of the loop or using conditionals when there are statements
     in the loop that are not in STMTS.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                               int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known(['ambn > 0', 'an > 0', 'bm > 0'])    for(j = 0; j < bm; j++) {
shift([1],1,4)                             C[i][j] = 0.0f;
print_code()                               for(n = 0; n < ambn; n++)
                                             C[i][j] += A[i][n] * B[n][j];
                                         }
                                     }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= an+3; t2++) {      void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= bm-1; t4++) {            int ambn, int an, int bm) {
    if (an >= t2+1) {                  int i, j, n;
      s0(t2,t4,0);                     for (i = 0; i <= an + 3; i += 1)
      if (t2 >= 4) {                     for (j = 0; j <= bm-1; j += 1)
        s1(t2-4,t4,0);                     if (i + 1 <= an) {
      }                                      C[i][j] = 0.0f;
      if (t2 >= 4) {                         if (4 <= i)
        for(t6 = 1; t6 <= ambn-1; t6++) {          C[i-4][j] += A[i-4][0]*B[0][j];
          s1(t2-4,t4,t6);                    if (4 <= i)
        }                                      for (n = 1; n <= ambn-1; n += 1)
      }                                          C[i-4][j] += A[i-4][n]*B[n][j];
    }                                      }
    else {                                 else if (4 <= i)
      if (t2 >= 4) {                         for (n = 0; n <= ambn-1; n += 1)
        for(t6 = 0; t6 <= ambn-1; t6++) {          C[i-4][j] += A[i-4][n]*B[n][j];
          s1(t2-4,t4,t6);            }
        }
      }
    }
  }
}

Shift_to
--------

 -- Transform: shift_to (int STMT, int LOOP, int AMOUNT)
     The 'shift_to' transformation adjusts the index of the loop at
     level LOOP by adding AMOUNT to the upper and lower bounds of the
     loop and then subtracting AMOUNT from every statement within the
     same loop structure as STMT.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                               int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known(['ambn > 0', 'an > 0', 'bm > 0'])    for(j = 0; j < bm; j++) {
shift_to(1,1,4)                            C[i][j] = 0.0f;
print_code()                               for(n = 0; n < ambn; n++)
                                             C[i][j] += A[i][n] * B[n][j];
                                         }
                                     }

Output on stdout                     Transformed code
for(t2 = 4; t2 <= an+3; t2++) {      void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= bm-1; t4++) {            int ambn, int an, int bm) {
    s0(t2-4,t4,0);                     int i, j, n;
    s1(t2-4,t4,0);                     for (i = 4; i <= an + 3; i += 1)
    for(t6 = 1; t6 <= ambn-1; t6++) {    for (j = 0; j <= bm-1; j += 1) {
      s1(t2-4,t4,t6);                      C[i-4][j] = 0.0f;
    }                                      C[i-4][j] += A[i-4][0]*B[0][j];
  }                                        for (n = 1; n <= ambn-1; n += 1)
}                                            C[i-4][j] += A[i-4][n]*B[n][j];
                                         }
                                     }

Skew
----

 -- Transform: skew (set<int> STMTS, int LOOP, vector<int> AMOUNT)
     The 'skew' transformation changes the index variable of the loop at
     level LOOP to be a linear combination of the indexes that are less
     than or equal to the level being transformed.

     Let i_1, i_2, \dots{}, i_{loop} be the original loop indexes and
     let amount = (a_1, a_2, \dots{}, a_{loop}).  The new index
     i'_{loop} will be \sum\limits_{l = 1}^{loop} a_l i_l.

The example below takes an algorithm with a negative loop-carried
dependence and transforms it into one without a dependence.

Python Script                        Original code
from chill import *                  void f(float **a, int n, int m) {
source('skew.c')                       int i, j;
procedure('f')                         for (i = 1; i < n; i++)
loop(0)                                  for (j = 0; j < m; j++)
known(['n > 0', 'm > 1'])                  a[i][j] = a[i-1][j+1] + 1;
print_code()                         }
print_dep()

skew([0], 2, [1, 1])
print_code()
print_dep()

Output on stdout                     Transformed code
for(t2 = 1; t2 <= n-1; t2++) {       void f(float **a,int n,int m)
  for(t4 = 0; t4 <= m-1; t4++) {     {
    s0(t2,t4);                         int i, j;
  }                                    for (i = 1; i < n; i += 1)
}                                        for (j = i; j < i + m; j += 1)
                                           a[i][j-i] = (a[i-1][j-i+1]+1);
dependence graph:                    }
s0->s0: a:true(1, -1)


for(t2 = 1; t2 <= n-1; t2++) {
  for(t4 = t2; t4 <= t2+m-1; t4++) {
    s0(t2,-t2+t4);
  }
}

dependence graph:
s0->s0: a:true(1, 0)

Split
-----

 -- Transform: split (int STMT, int LOOP, int EXPR)
     The 'split' transformation divides the iteration space of the loop
     at level LOOP using the condition specified in EXPR for the
     statement in STMT.

     The condition in EXPR can refer to the value of the iteration of
     the loop nested at level n as "L<n>".  Only one expression is
     allowed and it may not contain logical operators and/or or multiple
     formulas.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
                                             int ambn, int an, int bm) {
source('mm.c')                         int i, j, n;
procedure('mm')                        for(i = 0; i < an; i++)
loop(0)                                  for(j = 0; j < bm; j++) {
known('ambn > 0')                          C[i][j] = 0.0f;
known('an > 0')                            for(n = 0; n < ambn; n++)
known('bm > 10')                             C[i][j] += A[i][n] * B[n][j];
split(1, 2, "L2 < 5")                    }
print_code()                         }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= an-1; t2++) {      #define __rose_lt(x,y) ((x)<(y)?(x):(y))
  for(t4 = 0; t4 <= 4; t4++) {       
    s0(t2,t4,0);                     void mm(float **A, float **B, float **C,
    s1(t2,t4,0);                             int ambn, int an, int bm) {
    for(t6 = 1; t6 <= ambn-1; t6++) {  int i, j, n;
      s1(t2,t4,t6);                    for (i = 0; i <= an - 1; i += 1) {
    }                                    for (j=0; j<=__rose_lt(4,bm-1);j+=1){
  }                                        C[i][j] = 0.0f;
  for(t4 = 5; t4 <= bm-1; t4++) {          C[i][j] += (A[i][0] * B[0][j]);
    s2(t2,t4,0);                           for (n = 1; n <= ambn - 1; n += 1)
    s3(t2,t4,0);                             C[i][j] += (A[i][n] * B[n][j]);
    for(t6 = 1; t6 <= ambn-1; t6++) {    }
      s3(t2,t4,t6);                      for (j = 5; j <= bm - 1; j += 1) {
    }                                      C[i][j] = 0.0f;
  }                                        C[i][j] += (A[i][0] * B[0][j]);
}                                          for (n = 1; n <= ambn - 1; n += 1)
                                             C[i][j] += (A[i][n] * B[n][j]);
                                         }
                                       }
                                     }

Tile
----

 -- Transform: tile (int STMT, int LOOP, int TILE_SIZE, int CONTROL_LOOP
          = 1, TileMethod METHOD = 0, int ALIGNMENT_OFFSET = 1,
          int ALIGNMENT_MULTIPLE = 1)

     The 'tile' transformation allows a loop dimension to be segregated
     into tiles, the execution of which are scheduled by a control loop
     placed outside the tiled loop.  The statements STMT and surrounding
     loops inside the control loop will be executed a tile at a time
     along the tiled dimension.

     The loop nest to tile is specified by STMT and LOOP.  The argument
     TILE_SIZE specifies the tile size, a value of 0 indicates no
     tiling, a value of 1 is similar to loop interchange and a value
     greater than 1 sets the tile size to that value.  The argument
     CONTROL_LOOP specifies the loop level where the controlling loop
     should be placed, the default is 1 or the outermost loop.  The
     argument METHOD specifies the tiling method, a value of 0 indicates
     that the index value of the control loop is the actual index to the
     start of the tile and is known as a "strided tile", a value of 1
     indicates that the index value of control loop is the value of the
     tile and must be multiplied by TILE_SIZE to get the index to the
     start of the tile.  The value of ALIGNMENT_OFFSET shifts the
     beginning of the area to tile consistent with the alignment
     constraint in ALIGNMENT_MULTIPLE.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                               int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known(['ambn > 0', 'an > 0', 'bm > 0'])    for(j = 0; j < bm; j++) {
tile(0,2,4)                                C[i][j] = 0.0f;
print_code()                               for(n = 0; n < ambn; n++)
                                             C[i][j] += A[i][n] * B[n][j];
                                         }
                                     }

Output on stdout                     Transformed code
chill test_tile.py                   #define __rose_lt(x,y) ((x)<(y)?(x):(y))
for(t2 = 0; t2 <= bm-1; t2 += 4) {   void mm(float **A, float **B, float **C,
  for(t4 = 0; t4 <= an-1; t4++) {            int ambn, int an, int bm) {
    for(t6 = t2; t6 <= min(t2+3,bm-1); t6++) {  int i, j, n, jj;
      s0(t4,t6,0);                     for (jj = 0; jj <= bm - 1; jj += 4)
      s1(t4,t6,0);                       for (i = 0; i <= an - 1; i += 1)
      for(t8 = 1; t8 <= ambn-1; t8++) {      for (j=jj; j<=__rose_lt(bm-1,jj+3);
        s1(t4,t6,t8);                           j+=1) {
      }                                      C[i][j] = 0.0f;
    }                                        C[i][j] += (A[i][0] * B[0][j]);
  }                                          for (n = 1; n <= ambn - 1; n += 1)
}                                                C[i][j] += (A[i][n] * B[n][j]);
                                           }
                                     }

Unroll
------

 -- Transform: unroll (int STMT, int LOOP, int UNROLL_AMOUNT, int
          CLEANUP_SPLIT_LEVEL)
     The 'unroll' transformation unrolls a specified number of
     iterations of a statement inside the loop at level LOOP.

Python Script                        Original code
from chill import *                  void mm(float **A, float **B, float **C,
source('mm.c')                            int ambn, int an, int bm) {
procedure('mm')                        int i, j, n;
loop(0)                                for(i = 0; i < an; i++)
known('ambn > 0', 'an > 0', 'bm > 0')    for(j = 0; j < bm; j++) {
distribute([0,1], 1)                       C[i][j] = 0.0f;
unroll(1, 3, 4)                            for(n = 0; n < ambn; n++)
print_code()                                 C[i][j] += A[i][n] * B[n][j];
                                         }
                                     }

Output on stdout                     Transformed code
for(t2 = 0; t2 <= an-1; t2++) {      #define __rose_gt(x,y) ((x)>(y)?(x):(y))
  for(t4 = 0; t4 <= bm-1; t4++) {    
    s0(t2,t4,0);                     void mm(float **A, float **B, float **C,
  }                                          int ambn, int an, int bm)
}                                    {
for(t2 = 0; t2 <= an-1; t2++) {        int i, j, n, over1;
  for(t4 = 0; t4 <= bm-1; t4++) {      over1 = 0;
    s2(t2,t4);                         for (i = 0; i <= an - 1; i += 1)
    for(t6 = 0; t6 <= -over1+ambn-1;     for (j = 0; j <= bm - 1; j += 1)
        t6 += 4) {                         C[i][j] = 0.0f;
      s1(t2,t4,t6);                    for (i = 0; i <= an - 1; i += 1)
      s4(t2,t4,t6);                      for (j = 0; j <= bm - 1; j += 1) {
    }                                      over1 = ambn % 4;
    for(t6 = max(0, ambn-over1);           for (n = 0; n <= -over1 + ambn - 1;
        t6 <= ambn-1; t6++) {                   n += 4) {
      s3(t2,t4,t6);                          C[i][j] += (A[i][n]*B[n][j]);
    }                                        C[i][j] += (A[i][n+1]*B[n+1][j]);
  }                                          C[i][j] += (A[i][n+2]*B[n+2][j]);
}                                            C[i][j] += (A[i][n+3]*B[n+3][j]);
                                           }
                                           for (n = __rose_gt(0,ambn - over1);
                                                n <= ambn - 1; n += 1)
                                             C[i][j] += (A[i][n] * B[n][j]);
                                         }
                                     }


File: chill.info,  Node: Index,  Prev: Third Chapter,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* antidependence:                        Second Chapter.      (line 173)
* control dependence:                    Second Chapter.      (line 154)
* data dependence:                       Second Chapter.      (line 161)
* dependence types:                      Second Chapter.      (line 151)
* direction vector:                      Second Chapter.      (line 259)
* distance vector:                       Second Chapter.      (line 229)
* iteration space:                       Second Chapter.      (line  92)
* iteration vector:                      Second Chapter.      (line  55)
* legality of transformations:           Second Chapter.      (line 303)
* loop-carried dependence:               Second Chapter.      (line 194)
* loop-independent dependence:           Second Chapter.      (line 194)
* output dependence:                     Second Chapter.      (line 178)
* true dependence:                       Second Chapter.      (line 167)

Function and Transformation Index
*********************************

 [index ]
* Menu:

* distribute:                            Third Chapter.       (line 114)
* exit:                                  Third Chapter.       (line  97)
* fuse:                                  Third Chapter.       (line 151)
* known:                                 Third Chapter.       (line 100)
* loop:                                  Third Chapter.       (line  60)
* loop <1>:                              Third Chapter.       (line  61)
* peel:                                  Third Chapter.       (line 186)
* permute:                               Third Chapter.       (line 230)
* permute <1>:                           Third Chapter.       (line 231)
* print_code:                            Third Chapter.       (line  75)
* print_dep:                             Third Chapter.       (line  81)
* print_space:                           Third Chapter.       (line  93)
* procedure:                             Third Chapter.       (line  55)
* remove_dep:                            Third Chapter.       (line 104)
* reverse:                               Third Chapter.       (line 269)
* scale:                                 Third Chapter.       (line 303)
* shift:                                 Third Chapter.       (line 337)
* shift_to:                              Third Chapter.       (line 386)
* skew:                                  Third Chapter.       (line 420)
* source:                                Third Chapter.       (line  50)
* split:                                 Third Chapter.       (line 468)
* tile:                                  Third Chapter.       (line 515)
* unroll:                                Third Chapter.       (line 571)



Tag Table:
Node: Top840
Node: First Chapter1307
Ref: First Chapter-Footnote-15823
Ref: First Chapter-Footnote-26063
Node: Second Chapter6366
Ref: Second Chapter-Footnote-119737
Node: Third Chapter19847
Node: Index49729

End Tag Table
