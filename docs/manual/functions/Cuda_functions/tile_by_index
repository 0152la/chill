@unnumberedsubsec Tile_by_index
@deftypefn {Transform} {} tile_by_index (int @var{stmt}, int @var{loop}, int @var{tile_size}, int @var{control_loop} = 1, TileMethod @var{method} = 0, int @var{alignment_offset} = 1, @* int @var{alignment_multiple} = 1) 

The @code{tile_by_index} transformation

{"i","j"} The index variables of the loops that will be tiled
{TI,TJ} The respective tile sizes for each index variable
{l1 control="ii",l2 control="jj"} A mapping that specifies control loop variable names and optionally renames tile loop index variables.
{"ii", "jj", "i", "j"} Final order of nested loops with update loop index names


@end deftypefn

@multitable @columnfractions .50 .50 
@item
@b{Python Script}
@smallformat
@cartouche
@verbatim
read_IR("normalMM")
TI=16
TJ=16
tile_by_index(["i","j"], [TI, TJ], {'l1_control': "ii", 'l2_control':"jj"}, ["ii","jj", "i", "j"], None)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
#define N 1024

void normalMM(float c[N][N], float a[N], float b[N]) {
  int i, j;

  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
        a[i] = a[i] + c[i][j] * b[j];
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@item
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
parameter_symtab has 3 entries
0  c
1  a
2  b


body_symtab has 2 entries
0  i
1  j


['i', 'j']
curOrder: i,j
idxNames: i,j

parameter_symtab has 3 entries
0  c
1  a
2  b


body_symtab has 2 entries
0  i
1  j



parameter_symtab has 3 entries
0  c
1  a
2  b


body_symtab has 4 entries
0  i
1  j
2  chill_t1
3  chill_t2


curOrder: ii,i,j
idxNames: ii,i,j

parameter_symtab has 3 entries
0  c
1  a
2  b


body_symtab has 4 entries
0  i
1  j
2  chill_t1
3  chill_t2



parameter_symtab has 3 entries
0  c
1  a
2  b


body_symtab has 6 entries
0  i
1  j
2  chill_t1
3  chill_t2
4  chill_t4
5  chill_t5


curOrder: ii,jj,i,j
idxNames: ii,jj,i,j
for(t2 = 0; t2 <= 63; t2++) {
  for(t4 = 0; t4 <= 63; t4++) {
    for(t6 = 16*t2; t6 <= 16*t2+15; t6++) {
      for(t8 = 16*t4; t8 <= 16*t4+15; t8++) {
        s0(t2,t6,t8);
      }
    }
  }
}


// ~cuda~ preferredIdx: ii
for (t2 = 0; t2 <= 63; t2 += 1) 
  // ~cuda~ preferredIdx: jj
  for (t4 = 0; t4 <= 63; t4 += 1) 
    // ~cuda~ preferredIdx: i
    for (t6 = 16 * t2; t6 <= 16 * t2 + 15; t6 += 1) 
      // ~cuda~ preferredIdx: j
      for (t8 = 16 * t4; t8 <= 16 * t4 + 15; t8 += 1) 
        a[t6] = a[t6] + c[t6][t8] * b[t8];// this source is derived from CHILL AST originally from file 'chill87ef8226-0e61-4713-afa4-05e17429a93f.c' as parsed by frontend compiler rose

#define N 1024

void normalMM(float c[1024][1024], float a[1024], float b[1024]) {
  int i;
  int j;
  for (i = 0; i < 1024; i++) 
    for (j = 0; j < 1024; j++) 
      a[chill_t4] = a[chill_t4] + c[chill_t4][chill_t5] * b[chill_t5];
}

@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
#define N 1024

void normalMM(float c[1024][1024], float a[1024], float b[1024]) {
  int chill_t5;
  int chill_t4;
  int i;
  int j;
  for (i = 0; i < 1024; i++) 
    for (j = 0; j < 1024; j++) 
      a[chill_t4] = a[chill_t4] + c[chill_t4][chill_t5] * b[chill_t5];
}
@end verbatim
@end cartouche
@end smallformat
@end multitable
